# 키패드 누르기 해설

>  **관련 문제**
>
>  [Exam67256Tests.java](../../src/test/java/org/fp024/lv01/Exam67256Tests.java)

좀 막힐때... JetBrains AI와 함깨 하면 희망이 보이는 것 같다. 😂😂😂



---

## 나

https://school.programmers.co.kr/learn/courses/30/lessons/67256

이 문제 풀이 전략에 대해서 코드 없이 설명한번 해줄레?

거리를 구하라는 것 같은데.. 어떤식으로 거리를 구해야할지 잘 안떠오른다. 😂😂😂



## AI Assistant

## `[키패드 누르기] 문제 풀이 전략` 문제 이해하기

이 문제는 스마트폰 키패드에서 숫자를 누를 때, 어느 손가락으로 누를지를 결정하는 문제입니다.

- 왼손은 `*`에서 시작, 오른손은 `#`에서 시작
- 1, 4, 7은 항상 왼손으로
- 3, 6, 9는 항상 오른손으로
- 2, 5, 8, 0은 현재 각 손가락의 위치에서 더 가까운 손가락으로 누름
- 거리가 같으면 주 손잡이(hand 파라미터)에 따라 결정

## 거리 계산 전략

키패드 위에서의 거리는 **맨해튼 거리(Manhattan Distance)** 개념을 사용하면 됩니다. 이는 격자 구조에서 두 위치 사이의 최단 경로를 의미합니다.

### 1. 키패드를 2차원 좌표로 표현하기

```
1(0,0) 2(0,1) 3(0,2)
4(1,0) 5(1,1) 6(1,2)
7(2,0) 8(2,1) 9(2,2)
*(3,0) 0(3,1) #(3,2)
```

이렇게 각 숫자에 좌표를 부여하면 거리 계산이 쉬워집니다.

### 2. 맨해튼 거리 계산하기

두 위치 (r1, c1)과 (r2, c2) 사이의 맨해튼 거리는: `|r1 - r2| + |c1 - c2|`

예를 들어:

- 5(1,1)에서 8(2,1)까지의 거리: |1-2| + |1-1| = 1
- 4(1,0)에서 2(0,1)까지의 거리: |1-0| + |0-1| = 2

### 3. 구현 전략

1. **좌표 매핑**: 각 숫자와 *, #에 대한 좌표를 미리 정의합니다.

2. **현재 손가락 위치 추적**: 왼손과 오른손의 현재 위치를 계속 업데이트합니다.

3. **거리 계산 함수**: 두 위치 간의 맨해튼 거리를 계산하는 함수를 만듭니다.

4. 결정 로직

   :

   - 1, 4, 7이면 왼손 사용
   - 3, 6, 9면 오른손 사용
   - 2, 5, 8, 0이면 각 손가락에서의 거리를 계산하여 더 가까운 손 선택
   - 거리가 같으면 hand 파라미터에 따라 결정

## 풀이 단계

1. 숫자와 좌표를 매핑하는 데이터 구조 생성
2. 양손의 초기 위치 설정 (왼손: *, 오른손: #)
3. 입력된 numbers 배열을 순회하며:
   - 현재 숫자가 1, 4, 7이면 왼손 사용
   - 현재 숫자가 3, 6, 9면 오른손 사용
   - 현재 숫자가 2, 5, 8, 0이면:
     - 왼손과 오른손에서의 거리 계산
     - 더 가까운 손 사용 (거리 같으면 hand 파라미터 따름)
   - 사용한 손의 위치 업데이트
   - 사용한 손에 따라 'L' 또는 'R'을 결과 문자열에 추가
4. 최종 결과 문자열 반환

이 전략을 사용하면 키패드 누르기 문제를 효과적으로 해결할 수 있습니다. 가장 중요한 부분은 좌표 시스템을 활용하여 손가락 위치와 목표 버튼 사이의 거리를 계산하는 것입니다.

## 나

그런데 0, 0을 좌상단으로 기준으로 잡네?

## AI Assistant

네, 맞습니다! 좌표 시스템에서 (0, 0)을 좌상단으로 잡은 것입니다. 이것은 프로그래밍에서 흔히 사용하는 방식입니다.

## 좌표계 설명

일반적으로 프로그래밍에서 2차원 배열이나 그리드를 다룰 때:

- 첫 번째 값(행)은 위에서 아래로 증가 (↓)
- 두 번째 값(열)은 왼쪽에서 오른쪽으로 증가 (→)

이렇게 설정하면:

```
(0,0) (0,1) (0,2)
(1,0) (1,1) (1,2)
(2,0) (2,1) (2,2)
(3,0) (3,1) (3,2)
```

## 다른 좌표계 옵션

물론 좌표계는 다르게 설정할 수도 있습니다:

1. **중앙 기준**: 5를 (0,0)으로 하고 상하좌우로 좌표가 변하게 설정

```
1(-1,-1) 2(-1,0) 3(-1,1)
4(0,-1)  5(0,0)  6(0,1)
7(1,-1)  8(1,0)  9(1,1)
*(2,-1)  0(2,0)  #(2,1)
```

1. **수학적 좌표계**: 좌하단을 (0,0)으로 설정

```
*(0,0) 0(0,1) #(0,2)
7(1,0) 8(1,1) 9(1,2)
4(2,0) 5(2,1) 6(2,2)
1(3,0) 2(3,1) 3(3,2)
```

## 중요한 점

좌표계를 어떻게 설정하든 **일관성**만 유지하면 됩니다. 좌상단을 (0,0)으로 설정하는 것이 가장 직관적이고 프로그래밍에서 많이 사용되는 방식이라 이렇게 제안했습니다.

맨해튼 거리 계산에는 좌표계의 원점이 어디인지는 중요하지 않습니다. 두 점 사이의 행과 열의 차이의 절대값의 합으로 계산되기 때문입니다:

```
거리 = |r1 - r2| + |c1 - c2|
```

중요한 것은 모든 키패드 번호에 대해 일관된 좌표를 부여하고, 그 좌표를 기준으로 거리를 계산하는 것입니다!

## 나

그러면 `Map<번호, 좌표>`로 하고,

번호는 Integer,   좌표는 x,y를 맴버로 가지는 클래스로 하면 괜찮을까?

## AI Assistant

네, 그 접근 방법은 아주 좋습니다!

## 설계 제안

`Map<Integer, Coordinate>` 구조를 사용하면 키패드 번호와 좌표를 효과적으로 매핑할 수 있습니다.

### Coordinate 클래스 설계

```java
class Coordinate {
    private int row;
    private int col;
    
    public Coordinate(int row, int col) {
        this.row = row;
        this.col = col;
    }
    
    // getter 메서드
    public int getRow() { return row; }
    public int getCol() { return col; }
    
    // 맨해튼 거리 계산 메서드
    public int getDistance(Coordinate other) {
        return Math.abs(this.row - other.row) + Math.abs(this.col - other.col);
    }
}
```

### 키패드 매핑 구현

```java
// 키패드 좌표 매핑 초기화
Map<Integer, Coordinate> keypad = new HashMap<>();
keypad.put(1, new Coordinate(0, 0));
keypad.put(2, new Coordinate(0, 1));
keypad.put(3, new Coordinate(0, 2));
keypad.put(4, new Coordinate(1, 0));
keypad.put(5, new Coordinate(1, 1));
keypad.put(6, new Coordinate(1, 2));
keypad.put(7, new Coordinate(2, 0));
keypad.put(8, new Coordinate(2, 1));
keypad.put(9, new Coordinate(2, 2));
keypad.put(0, new Coordinate(3, 1));
// * 과 # 도 매핑 (숫자가 아니므로 다른 방식으로 처리할 수도 있음)
keypad.put(-1, new Coordinate(3, 0));  // * 를 -1로 표현
keypad.put(-2, new Coordinate(3, 2));  // # 를 -2로 표현
```

## 이 설계의 장점

1. **객체지향적**: Coordinate 클래스를 통해 좌표 관련 로직을 캡슐화합니다.
2. **확장성**: 거리 계산 등의 메서드를 클래스에 추가하여 코드 가독성을 높입니다.
3. **직관적**: 숫자와 좌표를 명확하게 매핑하여 이해하기 쉽습니다.

## 알고리즘 구현 개요

1. 위의 매핑과 Coordinate 클래스를 만듭니다.
2. 왼손과 오른손의 현재 위치를 Coordinate 객체로 관리합니다.
3. 각 숫자를 누를 때:
   - 왼쪽/오른쪽 전용 숫자인지 확인
   - 중간 숫자라면 getDistance() 메서드를 사용하여 양손과의 거리를 비교
   - 적절한 손을 사용하고 해당 손의 위치를 업데이트

이 접근법은 구조화되어 있고 이해하기 쉬우며, 문제 해결에 매우 적합합니다!

## 나

일단은 너가 알려준 개념대로 기본 테스트는 통과를 했어...

코드를 한번 봐볼레? #file:Exam67256Tests.java

## AI Assistant

코드를 봤는데, 아주 잘 구현하셨네요! 문제 해결 전략을 정확하게 적용하셨고 깔끔한 구조로 작성되었습니다. 👏

## 코드 분석

1. **Coordinate 클래스**: 좌표와 거리 계산 로직을 잘 캡슐화했습니다.

2. **키패드 매핑**: 숫자와 좌표를 HashMap으로 적절하게 매핑했습니다.

3. 로직 흐름

   :

   - 왼쪽 열(1,4,7,*)은 무조건 왼손
   - 오른쪽 열(3,6,9,#)은 무조건 오른손
   - 가운데 열(2,5,8,0)은 거리 계산 후 결정
   - 거리가 같으면 hand 파라미터에 따라 결정

## 특히 잘한 부분

1. **상수 정의**: `KEY_STAR`와 `KEY_SHARP` 상수를 정의하여 코드 가독성을 높였습니다.
2. **StringBuilder 활용**: 결과 문자열 생성에 `StringBuilder`를 사용하여 성능을 고려했습니다.
3. **깔끔한 조건문**: 거리 비교 및 손 선택 로직이 명확하게 구현되었습니다.

## 개선 가능한 부분

현재 코드는 기본 테스트를 통과했고 논리적으로도 문제가 없어 보입니다만, 아주 작은 개선점을 제안드립니다:

1. **getRow() 메서드 추가**: Coordinate 클래스에 `getRow()` 메서드도 추가하면 대칭성이 좋아집니다.
2. **hand 파라미터 검증**: "left"나 "right" 외의 값이 들어올 경우에 대한 검증을 추가할 수 있습니다.
3. **주석 추가**: 각 숫자의 위치가 키패드에서 어떻게 매핑되는지 간단한 도식을 주석으로 추가하면 더 이해하기 쉬울 것 같습니다.

## 총평

처음에는 거리 계산에 어려움을 느끼셨지만, 맨해튼 거리 개념을 이해하고 적절하게 적용하셨네요. 좌표 시스템과 객체지향적 접근을 통해 문제를 깔끔하게 해결하셨습니다. 이런 방식의 문제 해결은 다른 그리드 기반 문제에도 활용할 수 있는 좋은 패턴입니다.

앞으로도 이런 식으로 개념을 이해하고 구현하는 방식이라면 더 어려운 문제도 충분히 해결하실 수 있을 것 같습니다! 🎉

## 나

너가 제안한 개선 가능한 부분에서...

1. getRow()는 메인 solution 메서드에서 사용하는 부분이 없어서 지우긴 했었는데... 그냥 다시 추가했어..
2. 입력이 항상 정확하다는 가정이 있어서... 예외 처리까진 하지말고 if / else로만 나눠봤어.
3. Map을 구성하는 부분에다가 키패드 주석을 달아봣어..

한번 봐줄레? #file:Exam67256Tests.java

## AI Assistant

코드를 다시 확인해 봤는데, 매우 깔끔하게 개선되었습니다! 제안한 부분들을 잘 적용하셨네요. 👍

## 개선된 부분

1. **getRow() 메서드 추가**: Coordinate 클래스에 getRow() 메서드를 추가하여 일관성을 유지했습니다.
2. **조건문 간소화**: hand 확인 부분에서 if-else 구조를 사용하여 간결하게 처리했습니다. "left"가 아니면 "right"로 간주하는 방식이 문제 조건에 맞게 적절히 적용되었습니다.
3. **키패드 주석 추가**: 

```
    키 패드 매핑 좌표 구성

    1(0,0) 2(0,1) 3(0,2)
    4(1,0) 5(1,1) 6(1,2)
    7(2,0) 8(2,1) 9(2,2)
    *(3,0) 0(3,1) #(3,2)
```

이런 식으로 키패드 좌표 구성을 주석으로 추가하여 코드 이해도를 높였습니다.

1. **불필요한 변수 제거**: 이전에 있던 `answer` 변수를 제거하고 `result.toString()`을 바로 반환하여 코드를 더 간결하게 만들었습니다.

## 총평

이 코드는 이제 기능적으로도 완벽하고 가독성도 좋아졌습니다. 주요 로직은 그대로 유지하면서 코드 품질을 향상시키는 개선이 이루어졌습니다.

알고리즘 문제 해결에서 중요한 것은:

1. 명확한 개념 이해 (여기서는 맨해튼 거리)
2. 문제를 모델링하는 방법 (여기서는 좌표 시스템)
3. 깔끔한 코드 구현

이 세 가지를 모두 잘 해내셨습니다. 특히 처음에는 어렵게 느껴졌던 거리 계산 문제를 적절한 모델링을 통해 효과적으로 해결하신 점이 인상적입니다.

이런 방식의 문제 해결 접근법은 다양한 알고리즘 문제에 응용할 수 있을 것입니다. 계속해서 좋은 코딩하세요! 👏


# 주식가격 해설

>  **관련 문제**
>
>  * 완전 탐색
>    * [Exam42584Tests.java](../../src/test/java/org/fp024/lv02/Exam42584Tests.java)
>  * 스택 활용
>    * [Exam42584ATests.java](../../src/test/java/org/fp024/lv02/Exam42584ATests.java)

---

## 나:

주식가격 문제에 대해... 코드 없이 힌트만 줘볼레?

일단은 O(N^2)으로는 풀은 상태야.



## AI:

네, O(N^2)으로 푸셨군요! 효율성을 높이기 위한 힌트를 드릴게요. 문제 제목에 이미 힌트가 있네요.

### 힌트: 스택(Stack) 활용

1.  **관점의 전환**: `i`번째 가격을 기준으로 미래(`j`)를 보는 대신, 현재 시점(`i`)을 기준으로 **과거의 어떤 가격들이 하락했는지** 판단해보세요.

2.  **스택의 역할**: 스택에는 "아직 가격이 떨어지지 않은 주식의 **인덱스(index)**"를 저장합니다.

3.  **알고리즘 흐름**:
    *   가격을 순서대로 하나씩 확인합니다.
    *   스택의 맨 위(top)에 있는 인덱스에 해당하는 가격과 **현재 가격**을 비교합니다.
    *   만약 **현재 가격이 더 낮다면**, 스택 맨 위 가격은 드디어 하락한 것입니다!
        *   스택에서 인덱스를 꺼내고, (현재 시점 - 꺼낸 시점)으로 기간을 계산해서 `answer` 배열에 기록합니다.
        *   이 과정을 스택이 비거나, 스택 맨 위 가격이 현재 가격보다 작을 때까지 반복합니다.
    *   비교가 끝나면, **현재 시점의 인덱스**를 스택에 넣습니다.

4.  **마지막 처리**: 모든 가격을 다 확인했는데도 스택에 인덱스가 남아있다면, 그 주식들은 끝까지 가격이 떨어지지 않은 것들입니다. 이들의 기간을 어떻게 계산할지 생각해보세요.

이 아이디어를 바탕으로 코드를 다시 한번 구상해보시면 O(N)으로 해결하실 수 있을 겁니다.





## 나: [6, 9, 5, 7] 데이터로 확인 복기

ArrayDeque를 배열로 표현할 때.. top을 배열의 끝으로 간주하자 😅 원래는 앞 부터이지만... 뒤로 간주하는게 보기 편하겠다. 

| currentIndex | Stack                                            | answer                                             |
| ------------ | ------------------------------------------------ | -------------------------------------------------- |
| 0            | push(0)<br />[0]                                 |                                                    |
| 1            | push(1)<br />[0, 1]                              |                                                    |
| 2            | pop() -> 1<br />pop() -> 0<br />push(2)<br />[2] | answer[1] = 2 - 1 => 1<br />answer[0] = 2 - 0 => 2 |
| 3            | push(3)<br />[2 , 3]                             |                                                    |

인덱스 스택에 남은 내용 정리

| Stack      | answer            |
| ---------- | ----------------- |
| pop() -> 3 | [2,1, 0, `4-3-1`] |
| pop() -> 2 | [2,1, `4-1-2`, 0] |

최종 답은: `[2, 1, 1, 0]`

이렇게 복기를 해봄...



## AI:

아주 좋은 복기네요! 👍 표로 정리하신 것도 이해하기 쉽고, 흐름도 정확합니다!

### 복기 내용 검증:
✅ **스택 동작**: 정확
✅ **answer 계산**: 정확  
✅ **최종 결과**: `[2, 1, 1, 0]` 맞음

### 기억에 오래 남게 하는 팁:

**1. 핵심 패턴 기억하기**
```
"현재가 과거보다 작으면 → 과거들이 끝남"
```

**2. 스택의 역할 한 문장으로**
```
"아직 가격이 안 떨어진 주식들의 대기실"
```

**3. 공식 외우기**
- 중간에 끝난 경우: `기간 = 현재시점 - 과거시점`
- 끝까지 안 떨어진 경우: `기간 = (총길이 - 1) - 해당시점`

**4. 비슷한 문제들 연결하기**
- 다음 큰 원소 찾기
- 히스토그램에서 가장 큰 직사각형
- 괄호 유효성 검사

이런 패턴들이 모두 "스택으로 이전 상태를 기억해두고, 조건 만족 시 처리"하는 구조예요!

몇 번 더 비슷한 문제를 풀면 자연스럽게 체화될 거예요! 😊

